[{"content":"Lab6-Challenge实验报告 实现思路 添加命令 在user目录下，添加xxx.c 在user\\include.mk的USERAPPS中，添加xxx.b 一行多命令 在parsecmd函数中的switch-case语句中直接再添加case ';'，直接fork，子进程直接执行；左边的命令，父进程等待子进程运行命令结束后再运行；右边的命令\n1 2 3 4 5 6 7 8 9 10 case \u0026#39;;\u0026#39;: fktmp = fork(); if (fktmp) { wait(fktmp); return parsecmd(argv, rightpipe); } else { return argc; } break; 后台任务 类似于一行多命令的实现，直接在switch-case中添加caes '\u0026amp;'，直接fork，子进程直接执行\u0026amp;左边的命令，与实现一行多命令不一样的是，此时父进程不需要等待子进程执行完毕，直接执行右边的命令即可\n1 2 3 4 5 6 7 8 9 case \u0026#39;\u0026amp;\u0026#39;: fktmp = fork(); if (fktmp) { return parsecmd(argv, rightpipe); } else { return argc; } break; 需要注意的是，readline中调用read从控制台读入字符，当没有字符输入时，进程将阻塞在内核态，无法进行调度，因此为了实现后台任务，需要改变进程阻塞的位置，使其在用户态阻塞，修改sys_cgetc和cons_read即可\n1 2 3 4 5 6 7 int sys_cgetc(void) { int ch; // while ((ch = scancharc()) == 0) { // } ch = scancharc(); return ch; } 1 2 3 while ((c = syscall_cgetc()) == 0) { syscall_yield(); } 引号支持 为了实现引号支持，需要修改token的解析方式，即修改_gettoken函数，在函数中，当遇到左双引号时，解析出双引号内的整个字符串，并返回w，将其视为普通字符串而不解析为命令。\n1 2 3 4 5 6 7 8 9 10 if (*s == \u0026#39;\\\u0026#34;\u0026#39;) { *p1 = ++s; while (*s \u0026amp;\u0026amp; *s != \u0026#39;\\\u0026#34;\u0026#39;) { s++; } *s = 0; *p2 = s; return \u0026#39;w\u0026#39;; } 键入命令时任意位置的修改 首先要明确键盘上的方向键也对应一个字符，当按下上下左右任意按键时，代码中的readline函数也能读取到对应字符，四个按键的字符映射如下：\nUP: \\033[A DOWN: \\033[B Left: \\033[D Right: \\033[C 我们需要修改readline函数，使之能够处理相应按键的触发，代码的主要逻辑是维护当前光标的位置和buf字符串，每次输入普通字符或者输入退格符时，保存光标之后的字符串，依次输出光标前的字符串、输入字符或退格符、光标后的字符串。同时要注意光标左右移动的边界，在此我通过维护buf字符串的长度来实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 void readline(char *buf, u_int n) { int r; int len = 0;\t// buf长度 int i = 0;\t// 光标位置 int hisindex = hislen; // 历史命令位置 char temp; char histmp[128]; while (i \u0026lt; n) { if ((r = read(0, \u0026amp;temp, 1)) != 1) { if (r \u0026lt; 0) { debugf(\u0026#34;read error: %d\\n\u0026#34;, r); } exit(); } if (temp == \u0026#39;\\b\u0026#39; || temp == 0x7f) { if (i \u0026gt; 0) { if (i == len) { buf[--i] = 0; MOVELEFT(1); printf(\u0026#34; \u0026#34;); MOVELEFT(1); } else { for (int j = i - 1; j \u0026lt; len - 1; j++) { buf[j] = buf[j + 1]; } buf[len - 1] = 0; MOVELEFT(i--); // 往前挪i个位置到最左 printf(\u0026#34;%s \u0026#34;, buf); MOVELEFT(len - i); // 复位 } len -= 1; } } else if (temp == \u0026#39;\\033\u0026#39;) { // 方向键 switch (getDir()) { case 1: // up MOVEDOWN(1); if (hisindex \u0026gt; 0) { hisindex--; getHis(hisindex, histmp); strcpy(buf, histmp); flushLine(len, i); printf(\u0026#34;%s\u0026#34;, buf); len = strlen(buf); i = len; } break; case 2: // down if (hisindex \u0026lt; hislen) { hisindex++; getHis(hisindex, histmp); strcpy(buf, histmp); flushLine(len, i); printf(\u0026#34;%s\u0026#34;, buf); len = strlen(buf); i = len; } break; case 3: // left if (i \u0026gt; 0) { i -= 1; } else { MOVERIGHT(1); // 抵消 } break; case 4: // right if (i \u0026lt; len) { i += 1; } else { MOVELEFT(1); // 抵消 } break; default: break; } } else if (temp == \u0026#39;\\r\u0026#39; || temp == \u0026#39;\\n\u0026#39;) { buf[len] = 0; return; } else { // 普通字符 if (i == len) { buf[i++] = temp; } else { // i \u0026lt; len for (int j = len; j \u0026gt; i; j--) { buf[j] = buf[j - 1]; } buf[i] = temp; buf[len + 1] = 0; MOVELEFT(++i); printf(\u0026#34;%s\u0026#34;, buf); MOVELEFT(len - i + 1); } len += 1; } if (len \u0026gt;= n) { break; } } debugf(\u0026#34;line too long\\n\u0026#34;); while ((r = read(0, buf, 1)) == 1 \u0026amp;\u0026amp; buf[0] != \u0026#39;\\r\u0026#39; \u0026amp;\u0026amp; buf[0] != \u0026#39;\\n\u0026#39;) { ; } buf[0] = 0; } 程序名称中 .b 的省略 这个功能实现起来比较简单，当输入的程序路径无法打开时，在后面追加.b再次尝试打开即可\n1 2 3 4 5 6 7 8 9 10 11 int fd; char progTmp[MAXPATHLEN]; char after[] = \u0026#34;.b\u0026#34;; if ((fd = open(prog, O_RDONLY)) \u0026lt; 0) { strcpy(progTmp, prog); int len = strlen(prog); strcpy(progTmp + len, after); if ((fd = open(progTmp, O_RDONLY)) \u0026lt; 0) { return fd; } } tree命令 tree [-adf] [directory...]\n当没有directory参数时，将根目录作为参数。\n实现了三种参数形式：\n-a 显示所有的文件和目录，默认为 -a； -d 显示所有的目录； -f 显示文件和目录的完整路径。 在命令执行的过程中，也记录了文件和目录的数目，并在末尾输出。\n实现方式也不难，采用深度优先搜索dfs即可\n处理目录的函数 1 void treedir(char *path, char *name, int depth); 处理普通文件的函数 1 void treeReg(char *path, char *name, int depth); 其中depth表示目录深度\n1 treedir(path, st.st_name, 0);//从此进入dfs 当遍历到一个目录时，进行递归，深度加一\n1 2 3 4 5 6 7 8 9 while ((n = readn(fd, \u0026amp;f, sizeof(f))) == sizeof(f)) { if (f.f_name[0]) { if (f.f_type == FTYPE_REG) { treeReg(newpath, f.f_name, depth + 1); } else if (f.f_type == FTYPE_DIR) { treedir(newpath, f.f_name, depth + 1); } } } mkdir命令\u0026amp;touch命令 mkdir dirname\ntouch filename\n在MOS的文件系统中已经有了创建文件的功能，我们只需要进行一定的封装，通过IPC实现用户进程和文件系统服务进程的交互。在fs/fs.c中已有函数file_create，模仿在file.c中的其他用户接口实现create用户接口\n在user\\include\\fsreq.h中添加IPC时用到的结构体 1 2 3 4 5 #define FSREQ_CREATE 8 struct Fsreq_create { char req_path[MAXPATHLEN]; int f_type; }; 在user\\include\\lib.h中声明以下函数 1 2 int fsipc_create(const char *, int); int create(const char *path, int f_type); 在fs\\serv.h中声明以下函数 1 int file_create(char *path, struct File **file); 实现用户库函数，其中调用fsipc_create 1 2 3 int create(const char *path, int f_type) { return fsipc_create(path, f_type); } 实现fsipc_create函数，通过IPC让文件系统完成后续文件的创建 1 2 3 4 5 6 7 8 9 10 11 12 int fsipc_create(const char *path, int f_type) { int len = strlen(path); if (len == 0 || len \u0026gt; MAXPATHLEN) { return -E_BAD_PATH; } struct Fsreq_create *req = (struct Fsreq_create *)fsipcbuf; req-\u0026gt;f_type = f_type; strcpy(req-\u0026gt;req_path, path); return fsipc(FSREQ_CREATE, req, 0, 0); } 实现serve_create函数，并在switch-case中添加相应的case 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void serve_create(u_int envid, struct Fsreq_create *rq) { int r; struct File *f; if ((r = file_create(rq-\u0026gt;req_path, \u0026amp;f)) \u0026lt; 0) { ipc_send(envid, r, 0, 0); return; } f-\u0026gt;f_type = rq-\u0026gt;f_type; ipc_send(envid, 0, 0, 0); } case FSREQ_CREATE: serve_create(whom, (struct Fsreq_create *)REQVA); break; 以上完成之后只需新建mkdir.c、touch.c，在其中调用创建文件的用户接口，传入文件类型即可\n1 2 3 if ((fd = create(argv[i], FTYPE_DIR)) \u0026lt; 0) { user_panic(\u0026#34;error create directory %s: %d\\n\u0026#34;, argv[i], fd); } 1 2 3 if ((fd = create(argv[i], FTYPE_REG)) \u0026lt; 0) { user_panic(\u0026#34;error create file %s: %d\\n\u0026#34;, argv[i], fd); } 修改重定向输出\n1 2 3 4 5 6 7 8 9 case \u0026#39;\u0026gt;\u0026#39;: ... if ((r = open(t, O_WRONLY)) \u0026lt; 0) { if (create(t, FTYPE_REG) \u0026lt; 0) { user_panic(\u0026#34;\u0026gt; open failed\u0026#34;); } r = open(t, O_WRONLY); } ... 历史命令功能 初始化历史命令记录文件 1 2 3 4 5 6 7 8 9 10 11 void his_init() { int fd; if ((fd = open(\u0026#34;/.history\u0026#34;, O_RDONLY)) \u0026gt;= 0) { close(fd); return; } if (create(\u0026#34;/.history\u0026#34;, FTYPE_REG) \u0026lt; 0) { user_panic(\u0026#34;create .history failed\u0026#34;); } } 在每次读取到一行命令后就进行保存 1 2 readline(buf, sizeof buf); saveCmd(buf); 维护历史命令的条数和每条历史命令在history文件中的偏移 1 2 int hislen; int his_offsetTb[MAXHISNUM]; 由于MOS文件系统的文件打开模式不包括append，对history文件的追加写很不方便，因此先实现O_APPEND文件打开模式，在file.c的open函数中添加以下内容，将文件描述符中的偏移设置为文件的大小 1 2 3 if (mode \u0026amp; O_APPEND) { fd-\u0026gt;fd_offset = ffd-\u0026gt;f_file.f_size; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void saveCmd(char *cmd) { int fd; int r; if ((fd = open(\u0026#34;/.history\u0026#34;, O_WRONLY | O_APPEND)) \u0026lt; 0) { user_panic(\u0026#34;open .history failed\u0026#34;); } if ((r = write(fd, cmd, strlen(cmd))) != strlen(cmd)) { user_panic(\u0026#34;write error .history: %d\\n\u0026#34;, r); } if ((r = write(fd, \u0026#34;\\n\u0026#34;, 1)) != 1) { user_panic(\u0026#34;write error .history: %d\\n\u0026#34;, r); } his_offsetTb[hislen++] = strlen(cmd) + 1 + (hislen \u0026gt; 0 ? his_offsetTb[hislen - 1] : 0); close(fd); } 编写getHis函数，实现历史命令的随机访问，使用到了seek函数和readn函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void getHis(int index, char *cmd) { int fd; int r; if ((fd = open(\u0026#34;/.history\u0026#34;, O_RDONLY)) \u0026lt; 0) { user_panic(\u0026#34;open .history failed\u0026#34;); } if (index \u0026gt;= hislen) { *cmd = 0; return; } int offset = (index \u0026gt; 0 ? his_offsetTb[index - 1] : 0); int len = (index \u0026gt; 0 ? his_offsetTb[index] - his_offsetTb[index - 1] : his_offsetTb[index]); if ((r = seek(fd, offset)) \u0026lt; 0) { user_panic(\u0026#34;seek failed\u0026#34;); } if ((r = readn(fd, cmd, len)) != len) { user_panic(\u0026#34;read history failed\u0026#34;); } close(fd); cmd[len - 1] = 0; } 通过编写以上内容，已经具备实现历史命令的基本条件，接下来需要修改readline中处理键盘上下键的地方，我通过维护当前历史命令的下标hisindex来实现上下键历史命令的切换，每次readline时，初始化hisindex为当前历史命令的总条数hislen。\n形式化步骤如下：\n维护光标的位置 根据当前历史命令下标获取历史命令 刷新控制台并写入历史命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 int hisindex = hislen; // 历史命令位置 char histmp[128]; case 1: // up MOVEDOWN(1); if (hisindex \u0026gt; 0) { hisindex--; getHis(hisindex, histmp); strcpy(buf, histmp); flushLine(len, i); printf(\u0026#34;%s\u0026#34;, buf); len = strlen(buf); i = len; } break; case 2: // down if (hisindex \u0026lt; hislen) { hisindex++; getHis(hisindex, histmp); strcpy(buf, histmp); flushLine(len, i); printf(\u0026#34;%s\u0026#34;, buf); len = strlen(buf); i = len; } break; 最后实现history命令，编写history.c文件，打开.history文件，将其中的内容格式化输出即可，用到open和read两个函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 if ((r = open(\u0026#34;/.history\u0026#34;, O_RDONLY)) \u0026lt; 0) { user_panic(\u0026#34;open history failed\u0026#34;); } f = r; while ((r = read(f, \u0026amp;buf, 1)) == 1) { if (newline) { printf(\u0026#34;%-5d \u0026#34;, linecnt++); newline = 0; } printf(\u0026#34;%c\u0026#34;, buf); if (buf == \u0026#39;\\n\u0026#39;) { newline = 1; } } shell环境变量 我的做法是通过系统调用，在内核中维护环境变量，实现对环境变量的增删改查\n首先定义保存环境变量相关信息的结构体：\n1 2 3 4 5 6 7 8 struct shell_var { char name[MAXVARNAMELEN]; char value[MAXVARVALUELEN]; int shellid; int share;//1表示为环境变量 int rdonly;//1表示为只读 int valid;//1表示该变量是否有效 } 再实现系统调用，以下是四个用户态的系统调用部分\nsyscall_shellid_alloc用户给每个shell进程分配一个id用于标识环境变量是被哪个环境变量创建的 syscall_declare_shell_var用于声明一个环境变量或者修改环境变量 syscall_unset_shell_var用户删除一个环境变量 syscall_get_shell_var用于获得某个环境变量的值 1 2 3 4 int syscall_declare_shell_var(int shellid, char *name, char *value, int share, int rdonly); int syscall_unset_shell_var(int shellid, char *name); int syscall_get_shell_var(int shellid, char *name, char *value); int syscall_shellid_alloc(); 需要注意的时，在实现这四个系统调用时，需要判断内核中保存的环境变量对当前shell进程是否可见，因此我定义了一个isvisible函数，用于判断某个变量是否可见。同时为了实现简单，规定对于所有shell进程，其可见的变量不会出现重名的情况，即在实现declare的时候，优先在可见的变量中查找有无名字为参数name的变量\n以下是内核态中的系统调用部分\n1 2 3 int sys_shellid_alloc() { return ++sid; } 在实现declare和unset时，需要注意判断可见性和只读性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int sys_declare_shell_var(int shellid, char *name, char *value, int share, int rdonly) { int varid = get_var(shellid, name); if (varid == -1) { varid = varnum++; } else if (VAR[varid].rdonly) { return -E_VAR_ERR; } strcpy(VAR[varid].name, name); strcpy(VAR[varid].value, value); VAR[varid].shellid = shellid; VAR[varid].share = share; VAR[varid].rdonly = rdonly; VAR[varid].valid = 1; return 0; } 1 2 3 4 5 6 7 8 9 10 int sys_unset_shell_var(int shellid, char *name) { int varid = get_var(shellid, name); if (varid == -1 || VAR[varid].rdonly) { return -E_VAR_ERR; } VAR[varid].valid = 0; return 0; } 实现get的时候，若传入参数name为空，则返回所有的可见变量信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 int sys_get_shell_var(int shellid, char *name, char *value) { char *tmp = value; if (name == 0) { for (int i = 0; i \u0026lt; varnum; i++) { if (isvisible(shellid, VAR[i]) \u0026amp;\u0026amp; VAR[i].valid) { strcpy(tmp, \u0026#34;name: \u0026#34;); tmp += 6; strcpy(tmp, VAR[i].name); tmp += strlen(VAR[i].name); strcpy(tmp, \u0026#34; value: \u0026#34;); tmp += 8; strcpy(tmp, VAR[i].value); tmp += strlen(VAR[i].value); strcpy(tmp, \u0026#34; mood: \u0026#34;); tmp += 7; if (VAR[i].rdonly) { *tmp++ = \u0026#39;r\u0026#39;; } else { *tmp++ = \u0026#39;w\u0026#39;; } if (VAR[i].share) { *tmp++ = \u0026#39;x\u0026#39;; } *tmp++ = \u0026#39;\\n\u0026#39;; } } return 0; } else { int varid = get_var(shellid, name); // printk(\u0026#34;varid:%d\\n\u0026#34;, varid); if (varid == -1) { return -E_VAR_ERR; } strcpy(value, VAR[varid].value); return 0; } return -E_VAR_ERR; } 完成上述功能后，需要修改shell部分\n在sh.c中，每次进入主函数都通过系统调用syscall_shellid_alloc获得当前shell的id 在parsecmd中，当遇到$时，解析后面的字符串为对应变量的值 在runcmd中，当命令为delcare或unset时，在参数列表argv末尾追加当前shell的id 实现declare命令 编写declare.c文件，根据传入的选项和参数列表进行相应的处理\n1 2 3 4 5 6 7 8 9 ARGBEGIN { default: usage(); case \u0026#39;x\u0026#39;: case \u0026#39;r\u0026#39;: flag[(u_char)ARGC()]++; break; } ARGEND 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 if (argc == 1) { char buf[4096]; if ((r = syscall_get_shell_var(shellid, 0, buf)) \u0026lt; 0) { printf(\u0026#34;declare wrong: %d\\n\u0026#34;, r); } printf(\u0026#34;%s\\n\u0026#34;, buf); } else if (argc == 2) { if ((r = syscall_declare_shell_var(shellid, argv[0], \u0026#34;\u0026#34;, share, rdonly)) \u0026lt; 0) { printf(\u0026#34;declare wrong: %d\\n\u0026#34;, r); } } else if (argc == 3) { val = argv[1]; if (val[0] == \u0026#39;=\u0026#39;) { val++; if ((r = syscall_declare_shell_var(shellid, argv[0], val, share, rdonly)) \u0026lt; 0) { printf(\u0026#34;declare wrong: %d\\n\u0026#34;, r); } } else { usage(); } } 实现unset命令 编写unset.c文件，根据传入的变量名使用系统调用即可\n1 2 3 4 5 6 for (i = 1; i \u0026lt; argc - 1; i++) { if ((r = syscall_unset_shell_var(shellid, argv[i])) \u0026lt; 0) { printf(\u0026#34;environment value %s isn\u0026#39;t declared or is readonly\\n\u0026#34;, argv[i]); } } 功能测试 一行多命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 $ echo 1;echo 12;echo 123 1 [00003805] destroying 00003805 [00003805] free env 00003805 i am killed ... [00003004] destroying 00003004 [00003004] free env 00003004 i am killed ... 12 [00004805] destroying 00004805 [00004805] free env 00004805 i am killed ... [00004004] destroying 00004004 [00004004] free env 00004004 i am killed ... 123 [00005004] destroying 00005004 [00005004] free env 00005004 i am killed ... [00002803] destroying 00002803 [00002803] free env 00002803 i am killed ... $ echo 123; 123 [00006805] destroying 00006805 [00006805] free env 00006805 i am killed ... [00006004] destroying 00006004 [00006004] free env 00006004 i am killed ... [00005803] destroying 00005803 [00005803] free env 00005803 i am killed ... $ ;echo 123 [00007804] destroying 00007804 [00007804] free env 00007804 i am killed ... 123 [00008004] destroying 00008004 [00008004] free env 00008004 i am killed ... [00007003] destroying 00007003 [00007003] free env 00007003 i am killed ... 后台任务 编写一个运行时间比较久的测试程序testbg.c 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;lib.h\u0026gt; int main() { int i; debugf(\u0026#34;a very slow code begin\\n\u0026#34;); for (i = 0; i \u0026lt;= 999999999; i++) ; debugf(\u0026#34;a very slow code end\\n\u0026#34;); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 $ testbg\u0026amp;echo 123 123 [00008803] destroying 00008803 [00008803] free env 00008803 i am killed ... [00007804] destroying 00007804 [00007804] free env 00007804 i am killed ... $ a very slow code begin echo 321 321 [0000a003] destroying 0000a003 [0000a003] free env 0000a003 i am killed ... [00009804] destroying 00009804 [00009804] free env 00009804 i am killed ... $ a very slow code end [00009005] destroying 00009005 [00009005] free env 00009005 i am killed ... [00008006] destroying 00008006 [00008006] free env 00008006 i am killed ... 可以看到testbg在后台运行\n引号支持 1 2 3 4 5 6 7 8 $ echo \u0026#34;ls.b | cat.b\u0026#34; ls.b | cat.b [0000b805] destroying 0000b805 [0000b805] free env 0000b805 i am killed ... [0000b006] destroying 0000b006 [0000b006] free env 0000b006 i am killed ... 键入命令时任意位置的修改 测试通过在键盘上依次按下1,2,3,4,⬅,⬅,a,b,c,Backspace,➡,x,y,z,enter，显示效果如下：\n1 2 3 4 5 $ 12ab3xyz4 spawn 12ab3xyz4: -10 [0000c006] destroying 0000c006 [0000c006] free env 0000c006 i am killed ... 程序名称.b的省略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ ls testarg.b cat.b pingpong.b testbss.b newmotd history.b testpiperace.b testpipe.b motd init.b num.b touch.b mkdir.b testfdsharing.b declare.b testbg.b ls.b echo.b sh.b tree.b unset.b halt.b testptelibrary.b .history [0000d005] destroying 0000d005 [0000d005] free env 0000d005 i am killed ... [0000c806] destroying 0000c806 [0000c806] free env 0000c806 i am killed ... $ echo 123 123 [0000e005] destroying 0000e005 [0000e005] free env 0000e005 i am killed ... [0000d806] destroying 0000d806 [0000d806] free env 0000d806 i am killed ... tree,mkdir,touch命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 $ mkdir dir1 $ touch dir1/file1 $ touch dir1/file2 $ mkdir dir1/dir11 $ touch dir1/dir11/file3 $ touch dir1/dir11/file4 $ mkdir dir1/dir12 $ touch dir1/dir12/file5 $ touch dir1/dir12/file6 $ tree dir1 dir1 |-- file1 |-- file2 |-- dir11 |-- file3 |-- file4 |-- dir12 |-- file5 |-- file6 2 directories, 6 files $ tree -d dir1 dir1 |-- dir11 |-- dir12 2 directories $ tree -f dir1 dir1 |-- dir1/file1 |-- dir1/file2 |-- dir1/dir11 |-- dir1/dir11/file3 |-- dir1/dir11/file4 |-- dir1/dir12 |-- dir1/dir12/file5 |-- dir1/dir12/file6 2 directories, 6 files 重定向 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ echo test123 \u0026gt; newfile [00015804] destroying 00015804 [00015804] free env 00015804 i am killed ... [00015003] destroying 00015003 [00015003] free env 00015003 i am killed ... $ cat newfile test123 [00017804] destroying 00017804 [00017804] free env 00017804 i am killed ... [00017003] destroying 00017003 [00017003] free env 00017003 i am killed ... 历史命令功能 输入序列history,enter,↑,↑,↑,↓,enter\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 $ history 1 mkdir dir1 2 mkdir dir2 3 mkdir dir3 4 touch dir1/file1 5 touch dir1/file2 6 mkdir dir1/dir11 7 touch dir1/dir11/file3 8 touch dir1/dir11/file4 9 tree 10 tree dir1 11 mkdir dir1/dir12 12 touch dir1/dir12/file5 13 touch dir1/dir12/file6 14 tree dir1 15 tree -d dir1 16 tree -f dir1 17 tree 18 tree -f 19 tree -f dir1 20 echo test123 \u0026gt; newfile 21 tree 22 cat newfile 23 history [00018804] destroying 00018804 [00018804] free env 00018804 i am killed ... [00018003] destroying 00018003 [00018003] free env 00018003 i am killed ... $ cat newfile test123 [00019804] destroying 00019804 [00019804] free env 00019804 i am killed ... [00019003] destroying 00019003 [00019003] free env 00019003 i am killed ... shell环境变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 $ declare -x var1 =1 $ declare -x var2 =2 $ declare var3 =3 $ echo $var3 3 $ declare name: var1 value: 1 mood: wx name: var2 value: 2 mood: wx name: var3 value: 3 mood: w $ sh shellid:2 ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: :: :: :: MOS Shell 2023 :: :: :: ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: $ declare name: var1 value: 1 mood: wx name: var2 value: 2 mood: wx $ declare -r var4 =4 $ unset var1 $ declare name: var2 value: 2 mood: wx name: var4 value: 4 mood: r $ declare var2 =5 $ declare name: var2 value: 5 mood: w name: var4 value: 4 mood: r $ declare var5 $ declare name: var2 value: 5 mood: w name: var4 value: 4 mood: r name: var5 value: mood: w $ unset var4 environment value var4 isn\u0026#39;t declared or is readonly $ declare var4 declare wrong: -14 困难和解决方案 命令运行出现的异步问题 在实现一行多命令时，需要确保命令执行顺序与输入顺序保持一致，解决方案是通过fork创建子进程，子进程直接运行左边的命令，\n父进程等待子进程运行完毕再运行右边的命令。\n内核态阻塞的问题 实现后台任务时，由于read函数的实现是在内核态进行阻塞，无法进行调度，因此解决方案是将阻塞的位置调整在用户态，使其能进行调度。\n方向键的监听 一开始并不了解方向键在系统中的存在形式，查找相关资料后，了解到每个方向键也对应着相应的字符，因此只需要判断输入的字符是否为方向键对应的字符即可\n解析形如-abc的参数的方法 起初并不了解这种参数的解析，但发现ls命令也有类似的参数，故阅读ls.c文件并查找相关资料后，学习到了这种参数的解析方法\n1 2 3 4 5 6 7 8 9 10 ARGBEGIN { default: usage(); case \u0026#39;d\u0026#39;: case \u0026#39;F\u0026#39;: case \u0026#39;l\u0026#39;: flag[(u_char)ARGC()]++; break; } ARGEND 文件打开模式O_APPEND的实现 MOS的文件系统中并没有实现追加打开方式，实现该模式，需要在打开文件时，将文件描述符里存的偏移设置为文件大小\n历史命令的保存 仅有一个.history文件对存取是不方便的，因此我维护了一个偏移表，进行历史命令的存取。\n","date":"2023-07-19T17:42:39+08:00","image":"https://zyh-ovo.github.io/blog-by-stack/p/buaa-2023-os-lab6-challenge/mos_hu8555b497dd7481f472251d8ac0e75d4d_36648_120x120_fill_q75_box_smart1.jpg","permalink":"https://zyh-ovo.github.io/blog-by-stack/p/buaa-2023-os-lab6-challenge/","title":"BUAA 2023 OS Lab6 Challenge"},{"content":"busuanzi 大多数博客都是静态网站，静态既是优点也是缺点，优点包括但不限于快速的加载速度、较低的服务器要求以及更高的安全性等等；但同时由于是静态的，一些动态内容（交互等等）需要借助第三方平台，不蒜子（busuanzi）是由Bruce 开发的一款轻量级的网页计数器。使用非常简单：两行代码可搞定， 一行脚本，一行标签。\n统计指标 busuanzi有两种统计指标，PV和UV\nPV 即 Page View，网站浏览量指页面的浏览次数，用以衡量网站用户访问的网页数量。用户每打开一个页面便记录 1 次 PV，多次打开同一页面会累计浏览量。 UV 即 Unique Visitor，独立访客数指 1 天内访问某站点的人数，以 cookie 为依据。1 天内同一访客的多次访问只计为 1 个访客。 简单使用示例 先引入busuanzi的js代码 1 \u0026lt;script async src=\u0026#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 按需使用Html标签代码，注意要使用对应的id，例如网站总访问量要使用busuanzi_container_site_pv和busuanzi_value_site_pv。下面是一个例子： 1 2 3 \u0026lt;span id=\u0026#34;busuanzi_container_site_pv\u0026#34;\u0026gt;本站总访问量\u0026lt;span id=\u0026#34;busuanzi_value_site_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;次\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;busuanzi_container_site_uv\u0026#34;\u0026gt;本站总访客数\u0026lt;span id=\u0026#34;busuanzi_value_site_uv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;人\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;busuanzi_container_page_pv\u0026#34;\u0026gt;本文总阅读量\u0026lt;span id=\u0026#34;busuanzi_value_page_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;次\u0026lt;/span\u0026gt; Hugo引入 本站采用的是Stack主题，引入busuanzi时需要修改对应的模板页和配置文件，Stack主题的模板页结构如下图：\n修改的html文件有：\nlayouts\\partials\\article\\components\\content.html\nlayouts\\partials\\footer\\footer.html\nlayouts\\partials\\head\\head.html\nhead.html 在head.html中引入busuanzi的js代码\n1 2 3 4 5 \u0026lt;!-- busuanzi --\u0026gt; {{- if .Site.Params.busuanzi.enable -}} \u0026lt;script async src=\u0026#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;meta name=\u0026#34;referrer\u0026#34; content=\u0026#34;no-referrer-when-downgrade\u0026#34;\u0026gt; {{- end -}} footer.html footer.html定义了整个网站的底部结构，在其中添加总访客数\n1 2 3 4 5 6 7 {{ if .Site.Params.busuanzi.enable }} \u0026lt;div class=\u0026#34;busuanzi-footer\u0026#34;\u0026gt; \u0026lt;span id=\u0026#34;busuanzi_container_site_uv\u0026#34;\u0026gt; Total Visitors: \u0026lt;span id=\u0026#34;busuanzi_value_site_uv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; {{ end }} content.html content.html是所有文章内容的模板页，在其中添加文章的总浏览量，并且还可以使用自己想要的样式（我把颜色设成了浅蓝）\n1 2 3 4 {{ if .Site.Params.busuanzi.enable }} \u0026lt;span id=\u0026#34;busuanzi_container_page_pv\u0026#34; style=\u0026#34;color: rgb(60, 106, 255)\u0026#34;\u0026gt;Total Views: \u0026lt;span id=\u0026#34;busuanzi_value_page_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt; {{ end }} 配置文件 最后要修改配置文件params.toml，文件位置如下图所示：\n添加如下代码：\n1 2 [busuanzi] enable = true 如果不想使用计数功能，将enable设为false即可\n最终效果 文章浏览量\n网站访客数\n","date":"2023-07-19T16:36:28+08:00","permalink":"https://zyh-ovo.github.io/blog-by-stack/p/hugo%E7%BD%91%E7%AB%99%E5%BC%95%E5%85%A5%E8%AE%BF%E9%97%AE%E8%AE%A1%E6%95%B0%E6%8F%92%E4%BB%B6%E4%B8%8D%E8%92%9C%E5%AD%90busuanzi/","title":"Hugo网站引入访问计数插件不蒜子(busuanzi)"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $(\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…)$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2023-07-18T22:03:17+08:00","permalink":"https://zyh-ovo.github.io/blog-by-stack/p/math-typesetting/","title":"Math Typesetting"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nYouTube Privacy Enhanced Shortcode bilibilibi Shortcode Gist Shortcode Gitlab Snippets Shortcode Quote Shortcode Stack adds a quote shortcode. For example:\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Anonymous book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Some book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Somebody","date":"2023-07-18T21:55:17+08:00","permalink":"https://zyh-ovo.github.io/blog-by-stack/p/rich-content/","title":"Rich Content"},{"content":"Hugo Theme Stack Starter Template This is a quick start template for Hugo theme Stack. It uses Hugo modules feature to load the theme.\nIt comes with a basic theme structure and configuration. GitHub action has been set up to deploy the theme to a public GitHub page automatically. Also, there\u0026rsquo;s a cron job to update the theme automatically everyday.\nTo get started:\nClick Use this template, and create your repository on GitHub. Once the repository is created, create a GitHub codespace asociated with it. And voila! You\u0026rsquo;re ready to go. The codespace has been configured with the latest version of Hugo extended, just run hugo server in the terminal and see your new site in action.\nCheck config folder for the configuration files. You can edit them to suit your needs. Make sure to update the baseurl property in config/_default/config.toml to your site\u0026rsquo;s URL.\nOnce you\u0026rsquo;re done editing the site, just commit it and push it. GitHub action will deploy the site automatically to GitHub page asociated with the repository. In case you don\u0026rsquo;t want to use GitHub codespace, you can also run this template in your local machine. You need to install Git, Go and Hugo extended locally.\nUpdate theme manually Run:\n1 2 hugo mod get -u github.com/CaiJimmy/hugo-theme-stack/v3 hugo mod tidy This starter template has been configured with v3 version of theme. Due to the limitation of Go module, once the v4 or up version of theme is released, you need to update the theme manually. (Modifying config/module.toml file)\nDeploy to another static page hostings If you want to build this site using another static page hosting, you need to make sure they have Go installed in the machine.\nYou need to overwrite build command to install manually Go:\n1 amazon-linux-extras install golang1.11 \u0026amp;\u0026amp; hugo --gc --minify Make sure also to specify Hugo version in the environment variable HUGO_VERSION (Use the latest version of Hugo extended):\n","date":"2023-07-18T21:39:44+08:00","permalink":"https://zyh-ovo.github.io/blog-by-stack/p/hugo-theme-stack-starter-template/","title":"Hugo Theme Stack Starter Template"},{"content":"Welcome to Hugo theme Stack. This is your first post. Edit or delete it, then start writing!\nFor more information about this theme, check the documentation: https://docs.stack.jimmycai.com/\nWant a site like this? Check out hugo-theme-stack-stater\nPhoto by Pawel Czerwinski on Unsplash\n","date":"2022-03-06T00:00:00Z","image":"https://zyh-ovo.github.io/blog-by-stack/p/hello-world/cover_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://zyh-ovo.github.io/blog-by-stack/p/hello-world/","title":"Hello World"}]